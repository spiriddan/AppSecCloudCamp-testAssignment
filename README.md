# Тестовое задание на стажировку AppSecCloudCamp

На выполнение тестового задания у вас есть 7 дней.
Выполненное задание следует опубликовать на GitHub и отправить на почту **appseccloudcamp@cloud.ru**. Практическое задание состоит из нескольких частей, при этом, даже если вы сделали только одну часть задания - присылайте её на рассмотрение.
**ВАЖНО** При отправке тестового задания на почту обязательно указывайте ваши фамилию, имя, контактный номер телефон, telegram (при его наличии)

## 1. Вопросы для разогрева

1. Расскажите, с какими задачами в направлении безопасной разработки вы сталкивались?
   * В процессе работы обеспечивал безопасность работы своих web-сервисов:
     * внедрял генерацию `CSRF` токенов (`hash`, `crypto` и `jwt`)
     * защита от `XSS`, `SQLi`
     * Проверял репозиторий на наличие поверхностных уязвимостей (.env в коммите или подключение к бд в общем доступе)
2. Если вам приходилось проводить security code review или моделирование угроз, расскажите, как это было?
   * Моделирование угроз
     * обход форм на сайте и попытка дропнуть базу через `инъекцию` или вызвать `alert` на странице
   * Code review 
     * Проверка обращений в бд на наличие `prepared statements`
     * Наличие `санитайза` (или `escape`) текста, приходящего с фронта
     * Наличие проверки токенов в миддлварах на действиях, изменяющих данные пользователя в бд
3. Если у вас был опыт поиска уязвимостей, расскажите, как это было?
   * Проводил security code review
4. Почему вы хотите участвовать в стажировке?
   * Мне интересна сфера ИБ, интересен процесс моделирования атак на сервисы, поиск уязвимостей. Я хочу получить 
   практический опыт, глубже погрузиться в тему и развиться в этом направлении, познакомиться с интересными людьми и стать частью коммьюнити. 
---

## 2. Security code review

### Часть 1. Security code review: GO

Требуется провести анализ кода на GO с точки зрения безопасности и подготовить отчет по следующим пунктам:
- Какие уязвимости присутствуют в этом фрагменте кода?
- Указать строки, в которых присутствуют уязвимости.
- К каким последствиям может привести эксплуатация найденных уязвимостей злоумышленником?
- Описать способы исправления уязвимостей.
- Если уязвимость можно исправить несколькими способами, необходимо перечислить их, выбрать лучший по вашему мнению и аргументировать свой выбор.

1. Доступ к бд
   * `db, err = sql.Open("mysql", "user:password@/dbname")`
   * В коде хранится информация для доступа к бд
   * Если злоумышленник получит доступ к базе, он получает полный контроль над данными: могут утечь конфиденциальные данные пользователей, или злоумышленник может просто дропнуть базу, и сервис потеряет не только данные и клиентов, но и метрики с аналитикой
   * Решение:
     * Хранить эти данные в отдельном файле (обычно `.env`), который добавлен в `.gitignore` и никогда не коммитится. Для `локальной разработки` файл передаётся по закрытому защищенному каналу. 
     * В `проде` руками настроить `переменные окружения` и доставать информацию из них (локально переменные можно также загружать из файла)
2. SQLi
   * `query := fmt.Sprintf("SELECT * FROM products WHERE name LIKE '%%%s%%'", searchQuery)`
   * При конкатенации строк без какой-либо обработки может прийти SQL инъекция 
   * Злоумышленник может подставить строку так, что кроме нашего запроса выполнится и то, что он хочет, например:
     * `OR (1=1)` и сервер вернёт все записи, хранящиеся в таблице
     * `; DROP DATABASE` или просто удалить все данные, хранящиеся в базе
   * Решение
     * `Prepared statement`
       * Хранить запрос в бд как строку в константе с подстановкой переменных (`$1, $2`) или использовать `query builder` (который под капотом делает примерно то же самое)
       * `лучший способ` из-за его универсальности и повсеместного использования
     * Валидация на входе
       * `searchQuery := r.URL.Query().Get("query")`
       * Можно попробовать поймать инъекцию здесь, проанализировав ввод пользователя
       * Но ручная проверка может учитывать `не все шаблоны` и скорее всего это можно будет обойти
     * Сканировать в структуру 
       * От `drop table` не спасёт, но данные других таблиц не утекут. Способ `не решает проблему`, но может сгладить углы
       * `for rows.Next() {
         var name string
         err := rows.Scan(&name) ...` Происходит сканирование в строку, так что из базы можно вытащить какие угодно данные из любой таблицы. Если сканировать в структуру с фиксированными полями, сервер выдаст ошибку на сканировании не тех данных, которые ожидаются 
3. XSS
   * `searchQuery := r.URL.Query().Get("query")`
   * Ввод пользователя не санитайзится, так что может прийти вредоносный скрипт. На данном примере это `некритично`, поскольку мы ничего не записываем в базу, а только селектим, и база просто не найдёт нужного пользователя.


```
package main

import (
    "database/sql"
    "fmt"
    "log"
    "net/http"
    "github.com/go-sql-driver/mysql"
)

var db *sql.DB
var err error

func initDB() {
    db, err = sql.Open("mysql", "user:password@/dbname")
    if err != nil {
        log.Fatal(err)
    }

err = db.Ping()
if err != nil {
    log.Fatal(err)
    }
}

func searchHandler(w http.ResponseWriter, r *http.Request) {
    if r.Method != "GET" {
        http.Error(w, "Method is not supported.", http.StatusNotFound)
        return
    }

searchQuery := r.URL.Query().Get("query")
if searchQuery == "" {
    http.Error(w, "Query parameter is missing", http.StatusBadRequest)
    return
}

query := fmt.Sprintf("SELECT * FROM products WHERE name LIKE '%%%s%%'", searchQuery)
rows, err := db.Query(query)
if err != nil {
    http.Error(w, "Query failed", http.StatusInternalServerError)
    log.Println(err)
    return
}
defer rows.Close()

var products []string
for rows.Next() {
    var name string
    err := rows.Scan(&name)
    if err != nil {
        log.Fatal(err)
    }
    products = append(products, name)
}

fmt.Fprintf(w, "Found products: %v\n", products)
}

func main() {
    initDB()
    defer db.Close()

http.HandleFunc("/search", searchHandler)
fmt.Println("Server is running")
log.Fatal(http.ListenAndServe(":8080", nil))
}
```

### Часть 2: Security code review: Python

Требуется определить тип уязвимости в примерах кода на Python и ответить на следующие вопросы:
- Указать строки, в которых присутствуют уязвимости.
- К каким последствиям может привести эксплуатация данных уязвимостей злоумышленником?
- Описать способы исправления уязвимостей.
- Если уязвимость можно исправить несколькими способами, необходимо перечислить их, выбрать лучший по вашему мнению и аргументировать свой выбор.

*для примера №2.1*
1. XSS
   * `output = Template('Hello ' + name + '! Your age is ' + age + '.').render()`
   * Полученные данные конкатенируются с текстом без проверок, что ведёт к возможности вставки `вредоносного скрипта` (от простого `alert` до `редиректа` пользователя на фишинговый сайт)
   * Решение
     * Решение зависит от того, что мы ожидаем увидеть на фронте 
       * либо вы считаете, что во вводе вы поддерживаете `html`. тогда его надо `санитайзить`, а при отображении это должно работать как реальный html. То есть пользователь может намеренно вставлять html теги.
       * либо вы считаете, что у вас во вводе просто текст. тогда его нельзя `санитайзить`, а надо `эскейпить`.
      * На мой взгляд, второй вариант проще и удобнее, проверка на беке более легковесная (менее затратная)

*для примера №2.2*
1. OS command injection
   * `cmd = 'nslookup ' + hostname
     output = subprocess.check_output(cmd, shell=True, text=True)`
   * Ситуация похожа на `SQLi`, в исполняемую команду напрямую вставляются введённые пользователем данные, что ведёт к исполнению `любых` команд ОС: злоумышленник может получить доступ к исходному коду, базе данных, ребутнуть или уронить сервер, обратиться к git репозиторию и очистить историю, запустить на сервере майнер и так далее
   * Решение
     * Использовать список аргументов
       * как и с `prepared statement` передавать ввод пользователя не на прямую, а в качестве аргументов 
       * самый простой и удобный способ
     * Валидация ввода пользователя
       * Использовать функции валидации, которые предоставляет `Flask` 

**Пример №2.1**
```
from flask import Flask, request
from jinja2 import Template

app = Flask(name)

@app.route("/page")
def page():
    name = request.values.get('name')
    age = request.values.get('age', 'unknown')
    output = Template('Hello ' + name + '! Your age is ' + age + '.').render()
return output

if name == "main":
    app.run(debug=True)
```

**Пример №2.2**
```
from flask import Flask, request
import subprocess

app = Flask(name)

@app.route("/dns")
def dns_lookup():
    hostname = request.values.get('hostname')
    cmd = 'nslookup ' + hostname
    output = subprocess.check_output(cmd, shell=True, text=True)
return output
if name == "main":
    app.run(debug=True)
```

## 3. Моделировани угроз

Изучите диаграмму потоков данных (Data Flow Diagram, DFD) сервиса, обеспечивающего отправку информации в Telegram и Slack:

![DFD](https://github.com/appseccloudcamp/test-assignment/blob/main/test-dfd.png)

Краткое описание компонентов сервиса:
- **User** - авторизованный пользователь системы. Может настраивать отправку уведомлений и загружать изображения для дальнейшего использования при отправке уведомлений;
- **Microfront** - микрофронт, которые позволяет взаимодействовать с сервисом отправки информации;
- **Backend application** - набор микросервисов реализующих бизнес-логику приложения и обеспечивающих взаимодействие со всеми внешними сервисами;
- **Auth** - сервис отвечающий за аутентификацию и авторизацию клиентов сервиса отправки информации;
- **S3** - объектное хранилище, предназначенное для хранения статического контента сервиса отправки информации;
- **PostgreSQL** - база данных, предназначенная для хранения пользовательских конфигураций сервиса отправки информации.

Проанализируйте диаграмму потоков данных приложения и ответьте на следующий вопросы:
- Расскажите, какие потенциальные проблемы безопасности существуют для данного сервиса?
- Расскажите, к каким последствиям может привести эксплуатация проблем, найденных вами?
- Расскажите, какие способы исправления уязвимостей и смягчения рисков вы можете предложить по отмеченным вами проблемам безопасности?
- Напишите список уточняющих вопросов, которые вы бы задали разработчикам данного сервиса?

1. Авторизация
   * Недостаточно защищенная авторизация может привести к утечке данных пользователя
   * Возможно настроить `двухфакторную аутентификацию`, чтобы защитить пользователя
2. CSRF
   * Возможно отсутствие защиты от `CSRF`, когда происходит запрос от авторизованного пользователя без его участия
   * Настроить `CSRF токены`, подтверждающие действия пользователя
3. Валидация ввода пользователя
   * Неизвестно, настроена ли защита от `SQLi`, `OSCi`, `XSS`, но её отсутствие может привести к различным исходам: от утечки данных до полного контроля злоумышленником над сервером
4. Протокол взаимодействия
   * Злоумышленник может перехватить данные при передаче между `Microfront` и `Backend application`
   * Настроить `https` или иное `шифрование`
5. Доступ к PostgreSQL
   * Неизвестно, как хранится доступ к бд и кто к ней имеет доступ, возможна утечка или утеря данных
6. Доступ к S3
   * Неизвестно, как хранится доступ к бд, и кто к ней имеет доступ. При неправильной конфигурации пользователь может получить доступ к чужим файлам
7. Доступ к Telegram и Slack
   * При открытии канала для обращения к Telegram и Slack злоумышленник может перехватить запрос и данные пользователя будут отправляться ему, а не на перечисленные сервисы (или информация через руки злоумышленника будет передаваться в сервисы)

**Список уточняющих вопросов**
1. Как происходит авторизация пользователя? Что пользователю для этого нужно? Есть ли двухфакторная аутентификация? Как хранятся сессии пользователя? 
2. Есть ли `CSRF токены`? Если сессии пользователя не хранятся, используется ли `Double-Submit Cookie Pattern`?
3. Настроена ли защита от `SQLi`, `OSCi`, `XSS`: ввод `санитайзится`? используются ли `prepared statements`? 
4. Какой протокол взаимодействия? Как настроена защита передачи данных из внешней сети во внутреннюю?
5. Как хранится доступ к базам данных? Как происходит отдача статики пользователя? Может ли пользователь напрямую запросить файл из S3?
6. Как сервер получает доступ для отправки сообщений в Telegram и Slack? Где хранятся данные для авторизации? Происходит ли взаимодействие через web socket? Если да, как обеспечивается безопасность при открытии канала? 